package land.fx.fula;

import android.util.Log;

import androidx.annotation.NonNull;

import com.facebook.react.bridge.Promise;
import com.facebook.react.bridge.ReactApplicationContext;
import com.facebook.react.bridge.ReactContextBaseJavaModule;
import com.facebook.react.bridge.ReactMethod;
import com.facebook.react.module.annotations.ReactModule;

import org.jetbrains.annotations.Contract;

import java.io.File;
import java.nio.charset.StandardCharsets;
import java.util.Arrays;
import java.util.Base64;

import javax.crypto.SecretKey;

import fulamobile.Client;
import fulamobile.Config;
import fulamobile.Fulamobile;
import land.fx.wnfslib.LibKt;

@ReactModule(name = FulaModule.NAME)
public class FulaModule extends ReactContextBaseJavaModule {
  public static final String NAME = "FulaModule";
  Client fula;
  String appDir;
  String fulaStorePath;
  String privateForest;
  land.fx.wnfslib.Config rootConfig;
  SharedPreferenceHelper sharedPref;
  static String PRIVATE_KEY_STORE_ID = "PRIVATE_KEY";

  public FulaModule(ReactApplicationContext reactContext) {
    super(reactContext);
    appDir = reactContext.getFilesDir().toString();
    fulaStorePath = appDir + "/fula";
    File storeDir = new File(fulaStorePath);
    sharedPref = SharedPreferenceHelper.getInstance(reactContext.getApplicationContext());
    boolean success = true;
    if (!storeDir.exists()) {
      success = storeDir.mkdirs();
    }
    if (success) {
      Log.d(NAME, "Fula store folder created");
    } else {
      Log.d(NAME, "Unable to create fula store folder!");
    }
  }

  @Override
  @NonNull
  public String getName() {
    return NAME;
  }


  private byte[] toByte(@NonNull String input) {
    return input.getBytes(StandardCharsets.UTF_8);
  }

  @NonNull
  @Contract("_ -> new")
  private String toString(byte[] input) {
    return new String(input, StandardCharsets.UTF_8);
  }

  @NonNull
  private static int[] stringArrToIntArr(@NonNull String[] s) {
    int[] result = new int[s.length];
    for (int i = 0; i < s.length; i++) {
      result[i] = Integer.parseInt(s[i]);
    }
    return result;
  }

  @NonNull
  @Contract(pure = true)
  private static byte[] convertIntToByte(@NonNull int[] input) {
    byte[] result = new byte[input.length];
    for (int i = 0; i < input.length; i++) {
      byte b = (byte) input[i];
      result[i] = b;
    }
    return result;
  }

  @NonNull
  private static byte[] convertStringToByte(@NonNull String data) {
    String[] keyInt_S = data.split(",");
    int[] keyInt = stringArrToIntArr(keyInt_S);

    return convertIntToByte(keyInt);
  }

  @ReactMethod
  public void init(String identityString, String storePath, String bloxAddr, Promise promise) {
    Log.d("ReactNative", "init started");
    ThreadUtils.runOnExecutor(() -> {
      try {
        Log.d("ReactNative", "init storePath= " + storePath);
        byte[] identity = toByte(identityString);
        Log.d("ReactNative", "init identity= " + identityString);
        String[] obj = initInternal(identity, storePath, bloxAddr);
        Log.d("ReactNative", "init object created: [ " + obj[0] + ", " + obj[1] + ", " + obj[2] + " ]");
        promise.resolve(obj);
      } catch (Exception e) {
        Log.d("ReactNative", "init failed with Error: " + e.getMessage());
        promise.reject(e);
      }
    });
  }

  @NonNull
  private byte[] createPeerIdentity(byte[] privateKey) throws Exception {
    try {
      // 1: First: create public key from provided private key
      // 2: Should read the local keychain store (if it is key-value, key is public key above,
      // 3: if found, decrypt using the private key
      // 4: If not found or decryption not successful, generate an identity
      // 5: then encrypt and store in keychain

      String encryptedKey = sharedPref.getValue(PRIVATE_KEY_STORE_ID);
      SecretKey secretKey = Cryptography.generateKey(privateKey);
      if (encryptedKey == null) {
        byte[] autoGeneratedIdentity = Fulamobile.generateEd25519Key();
        encryptedKey = Cryptography.encryptMsg(StaticHelper.bytesToBase64(autoGeneratedIdentity), secretKey);
        sharedPref.add(PRIVATE_KEY_STORE_ID, encryptedKey);
      }
      return StaticHelper.base64ToBytes(Cryptography.decryptMsg(encryptedKey, secretKey));

    } catch (Exception e) {
      Log.d("ReactNative", "createPeerIdentity failed with Error: " + e.getMessage());
      throw (e);
    }
  }

  @NonNull
  private String[] initInternal(byte[] identity, String storePath, String bloxAddr) throws Exception {
    try {
      Config config_ext = new Config();
      if (storePath == null || storePath.trim().isEmpty()) {
        config_ext.setStorePath(fulaStorePath);
      } else {
        config_ext.setStorePath(storePath);
      }
      Log.d("ReactNative", "storePath is set: " + config_ext.getStorePath());

      byte[] peerIdentity = createPeerIdentity(identity);
      config_ext.setIdentity(peerIdentity);
      Log.d("ReactNative", "peerIdentity is set: " + toString(config_ext.getIdentity()));
      config_ext.setBloxAddr(bloxAddr);
      Log.d("ReactNative", "bloxAddr is set: " + config_ext.getBloxAddr());
      this.fula = Fulamobile.newClient(config_ext);
      Log.d("ReactNative", "fula initialized: " + this.fula.id());
      if (this.rootConfig == null) {
        Log.d("ReactNative", "creating rootConfig");
        this.privateForest = LibKt.createPrivateForest(this.fula);
        Log.d("ReactNative", "privateForest is created: " + this.privateForest);
        this.rootConfig = LibKt.createRootDir(this.fula, this.privateForest);
        Log.d("ReactNative", "rootConfig is created: " + this.rootConfig.getCid());
      } else {
        Log.d("ReactNative", "rootConfig existed: " + this.rootConfig.getCid());
      }
      String peerId = this.fula.id();
      String[] obj = new String[3];
      obj[0] = peerId;
      obj[1] = this.rootConfig.getCid();
      obj[2] = this.rootConfig.getPrivate_ref();
      Log.d("ReactNative", "initInternal is completed successfully");
      return obj;
    } catch (Exception e) {
      Log.d("ReactNative", "init internal failed with Error: " + e.getMessage());
      throw (e);
    }
  }

  @ReactMethod
  public void mkdir(String path, Promise promise) {
    ThreadUtils.runOnExecutor(() -> {
      Log.d("ReactNative", "mkdir: path = " + path);
      try {
        land.fx.wnfslib.Config config = LibKt.mkdir(this.fula, this.rootConfig.getCid(), this.rootConfig.getPrivate_ref(), path);
        this.rootConfig = config;
        promise.resolve(config.getCid());
      } catch (Exception e) {
        Log.d("get", e.getMessage());
        promise.reject(e);
      }
    });
  }

  @ReactMethod
  public void writeFileLocal(String path, String contentString, Promise promise) {
    ThreadUtils.runOnExecutor(() -> {
      Log.d("ReactNative", "writeFile: contentString = " + contentString);
      Log.d("ReactNative", "writeFile: path = " + path);
      try {
        byte[] content = convertStringToByte(contentString);
        land.fx.wnfslib.Config config = LibKt.writeFile(this.fula, this.rootConfig.getCid(), this.rootConfig.getPrivate_ref(), path, content);
        this.rootConfig = config;
        promise.resolve(config.getCid());
      } catch (Exception e) {
        Log.d("get", e.getMessage());
        promise.reject(e);
      }
    });
  }

  @ReactMethod
  public void ls(String path, Promise promise) {
    ThreadUtils.runOnExecutor(() -> {
      Log.d("ReactNative", "ls: path = " + path);
      try {
        String res = LibKt.ls(this.fula, this.rootConfig.getCid(), this.rootConfig.getPrivate_ref(), path);
        promise.resolve(res);
      } catch (Exception e) {
        Log.d("get", e.getMessage());
        promise.reject(e);
      }
    });
  }

  @ReactMethod
  public void readFile(String path, Promise promise) {
    ThreadUtils.runOnExecutor(() -> {
      Log.d("ReactNative", "ls: path = " + path);
      try {
        byte[] res = LibKt.readFile(this.fula, this.rootConfig.getCid(), this.rootConfig.getPrivate_ref(), path);
        String resString = toString(res);
        promise.resolve(resString);
      } catch (Exception e) {
        Log.d("get", e.getMessage());
        promise.reject(e);
      }
    });
  }

  @ReactMethod
  public void get(String keyString, Promise promise) {
    ThreadUtils.runOnExecutor(() -> {
      Log.d("ReactNative", "get: keyString = " + keyString);
      try {
        byte[] key = convertStringToByte(keyString);
        byte[] value = getInternal(key);
        String valueString = toString(value);
        promise.resolve(valueString);
      } catch (Exception e) {
        Log.d("get", e.getMessage());
        promise.reject(e);
      }
    });
  }

  @NonNull
  private byte[] getInternal(byte[] key) throws Exception {
    try {
      Log.d("ReactNative", "getInternal: key.toString() = " + toString(key));
      Log.d("ReactNative", "getInternal: key.toString().bytes = " + Arrays.toString(key));
      byte[] value = this.fula.get(key);
      Log.d("ReactNative", "getInternal: value.toString() = " + toString(value));
      return value;
    } catch (Exception e) {
      Log.d("ReactNative", "getInternal: error = " + e.getMessage());
      Log.d("getInternal", e.getMessage());
      throw (e);
    }
  }

  @ReactMethod
  public void has(String keyString, Promise promise) {
    ThreadUtils.runOnExecutor(() -> {
      Log.d("ReactNative", "has: keyString = " + keyString);
      try {
        byte[] key = convertStringToByte(keyString);
        boolean result = hasInternal(key);
        promise.resolve(result);
      } catch (Exception e) {
        Log.d("get", e.getMessage());
        promise.reject(e);
      }
    });
  }

  @NonNull
  private boolean hasInternal(byte[] key) throws Exception {
    try {
      boolean res = this.fula.has(key);
      return res;
    } catch (Exception e) {
      Log.d("hasInternal", e.getMessage());
      throw (e);
    }
  }

  @NonNull
  private void pullInternal(byte[] key) throws Exception {
    try {
      this.fula.pull(key);
    } catch (Exception e) {
      Log.d("pullInternal", e.getMessage());
      throw (e);
    }
  }

  @ReactMethod
  public void push(Promise promise) {
    ThreadUtils.runOnExecutor(() -> {
      Log.d("ReactNative", "push started");
      try {
        pushInternal(convertStringToByte(this.rootConfig.getCid()));
        promise.resolve(this.rootConfig.getCid());
      } catch (Exception e) {
        Log.d("get", e.getMessage());
        promise.reject(e);
      }
    });
  }

  @NonNull
  private void pushInternal(byte[] key) throws Exception {
    try {
      if (this.fula.has(key)) {
        this.fula.push(key);
      } else {
        Log.d("pushInternal", "error: key wasn't found");
        throw new Exception("key wasn't found in local storage");
      }
    } catch (Exception e) {
      Log.d("pushInternal", e.getMessage());
      throw (e);
    }
  }

  @ReactMethod
  public void put(String valueString, String codecString, Promise promise) {
    ThreadUtils.runOnExecutor(() -> {
      Log.d("ReactNative", "put: codecString = " + codecString);
      Log.d("ReactNative", "put: valueString = " + valueString);
      try {
        //byte[] codec = convertStringToByte(CodecString);
        long codec = Long.parseLong(codecString);


        Log.d("ReactNative", "put: codec = " + codec);
        byte[] value = toByte(valueString);

        Log.d("ReactNative", "put: value.toString() = " + toString(value));
        byte[] key = putInternal(value, codec);
        Log.d("ReactNative", "put: key.toString() = " + toString(key));
        promise.resolve(toString(key));
      } catch (Exception e) {
        Log.d("ReactNative", "put: error = " + e.getMessage());
        Log.d("put", e.getMessage());
        promise.reject(e);
      }
    });
  }

  @NonNull
  private byte[] putInternal(byte[] value, long codec) throws Exception {
    try {
      byte[] key = this.fula.put(value, codec);
      return key;
    } catch (Exception e) {
      Log.d("putInternal", e.getMessage());
      throw (e);
    }
  }

  @ReactMethod
  public void shutdown(Promise promise) {
    ThreadUtils.runOnExecutor(() -> {
      try {
        fula.shutdown();
        promise.resolve(true);
      } catch (Exception e) {
        promise.reject(e);
        Log.d("shutdown", e.getMessage());
      }
    });

  }

}
